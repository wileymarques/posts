# TypeScript

- O que é TypeScript
	- Uma ferramenta que nos ajuda a garantir a qualidade do código através de um sistema de tipagem
	- Muitos acham que JavaScript não tem tipos
	- Mas na verdade, apesar de ser fracamente tipada, os tipos estão lá
	- Só usar `typeof` em alguma variável para ver
	- Os mais comuns são `string`, `number`, `boolean`
	- TypeScript entra aqui para ajudar a escrever o código com esses tipos de maneira explícita
	- E nos “forçando” a usar o tipo correto
	- > Escrever código com tipagem
- Como compilar um código TypeScript para JavaScript
  - Mas o navegador, atualmente, não interpreta TypeScript e sim JavaScript
  - por isso, precisamos passar o nosso código por um processo de compilação, ou transpilação
  - uma das formas de fazer isso é utilizando a CLI do próprio typescript, instalando via npm
  - > instalar a CLI do typescript no node
  - > usar comando `tsc index.ts`
	- > Mostrar código gerado em JavaScript sem os tipos
	- apesar de ter tipos, TypeScript não garante type safety em runtime
	- Mas nos informa durante a escrita e compilação do código
  - apesar de o editor de código nos informar do erro no código, é possível ignorar e partir para a compilação
  - mas a CLI do typescript também já nos informa do mesmo erro
  - > Mostrar compilação do código ignorando erro na escrita
- Formatos (módulos) gerados (commonjs, es5, es2020)
	- Uma das coisas que fazemos para deixar o projeto legível é separar o código em arquivos separados
	- Podemos deixar, por exemplo, uma função em um arquivo separado e importar onde quisermos
	- > Criar um arquivo com uma função de soma, recebendo dois números e retornando a soma entre elas
	- Para fazer isso precisamos, nesse arquivo, exportar a função a ser reutilizada
  - > colocar `export` na frente da função
	- E importar onde queremos usar
  - > abrir `index.ts` e usar `import` para importar a função
	- Mas como isso fica em JavaScript após compilar?
	- > compilar arquivo com import/export para JS
  - podemos ver uma certa diferença no código que escrevemos e o que foi gerado na compilação
  - por exemplo, `const` virou `var` e o `export` e `import` foram convertidos para outra coisa
	- isso se dá ao fato de que essa sintaxe chamada de import/export é relativamente nova
	- e alguns sistemas, Node por exemplo, não teve esse suporte por bastante tempo
	- sem nem mencionar o IE (morreu?)
  - para o JS, hoje em dia, sendo bem simplista, é como se cada arquivo fosse um módulo
	- mas durante a vida do JS, alguns sistemas de módulos foram criados, antes dessa sintaxe de import/export
	- como o commonjs
	- e o typescript tem suporte a isso também
  - por padrão, quando compilamos com a CLI do typescript, o sistema de módulo usado é o commonjs
  - mas podemos alterar informando um valor no parâmetro `--module`
  - > compilar o mesmo código usando `--module es2020`
  - aqui, compilando com es2020 podemos ver import e export no código
  - mas as variáveis ainda são declaradas com `var`, ao invés de `const`
  - isso porque outra configuração importante é o `target`
  - que é basicamente o "alvo" de onde o código será executado
  - por padrão, o valor vem como es3 !!!
  - mas para alterar, basta colocar um valor diferente na flag `--target`
  - > compilar com target es2020
- Classes em TypeScript
  - agora vamos ver alguns exemplos de como alguns trechos de código são gerados pela tsc
  - começando com classes
  - > criar uma classe chamada `Calculadora` com atributos `n1` e `n2` privados
  - > com método chamado `subtrair`, retornando a substração de n2 de n1
  - > por serem privados, os valores serão recebidos via construtor
  - > colocar `export` na classe e importar no arquivo index.ts
  - > compilar e explicar o código gerado nos arquivos index.js e calculadora.js
  - classe vira function
  - porque classes não existiam em es3
  - compilar em es5 e mostrar que classes ainda não existiam
  - compilar para es2015 e ver que classes existem
  - porém tudo que é `private` e `public` sumiu do código, porque esse acessor só existe em TypeScript
  - como só existe em typescript, a checkagem de atributos e métodos privados só acontece em tempo de design e compilação, como vimos lá no começo
  - e ainda é possível acessar um atributo privado usando uma sagacidade
  - basta usar a sintaxe `['n1']`, apesar de altamente não recomendado
  - JS "puro" já tem uma sintaxe de atributos privados, usando um # na frente
  - > alterar classe Calculadora para usar # e testar rodando o deno
  - porém o código gerado em typescript é um tanto pesado, por usar WeakMap ao fazer o down leveling
  - para fazer o código gerado sem weakmaps, deve-se usar o target esnext
  - só que esnext é como se vc estivesse optando por uma espécie de beta, então precisa usar com cautela
